%INPUTS:
%fun: the mathematical function for which we want to compute the root
% note that the output of fun may include the derivative
% i.e. [fval,dfdx] = fun(x)
% or not, i.e. fval = fun(x)
%x_guess the initial guess for Newton's method
% solver_params: a MATLAB struct containing solver settings
% solver_params.dxtol: terminate early if |x_{i+1}-x_{i}|<dxtol
% solver_params.ftol: terminate early if |f(x_i)|<ftol
% solver_params.dxmax: terminate early if |x_{i+1}-x_{i}|>dxmax
% (meaning that jacobian is probably singular, which is bad)
% solver_params.numerical_diff: boolean (0 or 1)
% 
% 1-> numerically differentiate, 0-> use analytical derivative
% should use numerical differentation to compute the Jacobian or
% use a Jacobian generated by fun. No input assumes numerical by default
% true->fun is assumed to return [fval,J]
% false->fun is assumed to only return fval
%OUTPUTS:
%x: the estimate of the root computed by the function
% exit_flag: an integer indicating whether or not the solver succeeded
% 

function [x_root] = multi_newton_solver(fun,x_guess,solver_params)
    %unpack values from struct (if fields in struct have been set)
 
    dxtol = solver_params.dxtol;
    ftol = solver_params.ftol;
    max_iter = solver_params.max_iter;
    dxmax = solver_params.dxmax;
    numerical_diff =  solver_params.numerical_diff;
    
 
    if numerical_diff
        'size of x_guess'
        size(x_guess)
        fval = fun(x_guess);
        J = approximate_jacobian(fun, x_guess);
        
    else
        [fval,J] = fun(x_guess);
    end

    count = 0;
    delta_x = 1;

    while count < max_iter && norm(fval)> ftol && norm(delta_x) > dxtol && norm(delta_x) < dxmax
        count = count + 1;

        if numerical_diff

            fval = fun(x_guess);
            J = approximate_jacobian(fun, x_guess);
        else
            [fval,J] = fun(x_guess);
        end
    
        delta_x = -J\fval;
        x_guess = x_guess + delta_x;
        
    end
    

    x_root = x_guess;

    disp('Root is approx: ')
    disp(x_root)
    
    f_check = fun(x_root);
    disp('f(X_new) = ')
    disp(f_check)
end